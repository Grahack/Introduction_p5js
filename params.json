{
  "name": "Introduction p5js",
  "tagline": "This is a french introduction to p5*js",
  "body": "# Introduction_p5js\r\n\r\nThis is a french introduction to p5*js : http://p5js.org\r\n\r\nP5js est un projet issu de processing qui est un langage de programmation basé sur java orienté vers la création graphique et interactive. P5js a pour but de transposer l'esprit de processing au web et donc au langage javascript. C'est un framework simple d'accès pour les débutants avec une bonne documentation et une communauté active. \r\n\r\nP5js propose l'intégration dans un canvas html5 d'un maximum de fonction pour le dessin et d'animation, des possibilités d'interaction à travers différentes interfaces homme machine (clavier, souris, webcam, micro ...), ou encore avec les composants d'une page web et un support partiel mais en développement de webgl.\r\n\r\nDe nombreuses librairies viennent offrir de nouvelles possibilité, mais il p5js peut naturellement s'interfacer avec n'importe quelle librairies js.\r\n\r\nP5js est différent de processing.js par le fait que le langage de base est le js. Lorsqu'on utilise processing.js on a générallement développé un programme avec processing et on utilise processing.js pour traduire le programme en javascript qui devient alors exécutable dans une page web. Avec p5js on code directement en javascript un langage natif pour les navigateurs.\r\n\r\nCette introduction va couvrir l'essentiel du workflow avec p5js, présenter les différentes fonctions de dessin et la base de la programmation en js ( conditions, boucles for et fonction + prototypage d'objets javascript).\r\n\r\n<a name=\"contenu\"/>\r\n## Contenu\r\n\r\n* [Comment travailler avec p5js](#p5js_tools)<br>\r\n* [Principes de bases](#bases)<br>\r\n* [Dessiner avec la souris](#dessiner)<br>\r\n\t*\t[Les couleurs et la transparence](#couleurs)<br>\r\n\t*\t[Utilisation de variables](#simuler)<br>\r\n\t*\t[Réaliser des symétries](#symetries)<br>\r\n\t*\t[Créer des fonctions javascript](#fonctions)<br>\r\n\t*\t[Utiliser les transformations de l'espace : effet spirographe](#transformations)<br>\r\n\t*\t[Coordonnées polaires : effet \"spray-can\"](#spray)<br>\r\n* [Animation et objets](#animation)<br>\r\n* [Grilles](#grilles)<br>\r\n* [DOM](#dom)<br>\r\n* [SocketIO](#socket)<br>\r\n* [Ressources](#ressources)<br>\r\n* [Références](#references)<br>\r\n\r\n\r\n\r\n<a name=\"p5js_tools\"/>\r\n## Comment travailler avec p5js\r\n\r\nVous avez plusieurs choix : \r\n\r\n\r\n### openprocessing\r\n\r\nOpenprocessing est une plateforme collaborative qui permet de coder avec p5js ou processing.js. Il suffit de créer un compte gratuit et de cliquer sur 'create a new sketch' et c'est partit ! Openprocessing permet d'uploader des images, des vidéos ou des sons et supporte plusieurs librairies y compris un librairie websocket qui permet à plusieurs utilisateur d'interagir à distance dans un même canvas.\r\n\r\n[Openprocessing](http://openprocessing.org)\r\n\r\nLa plupart des exemples de ce cours seront probablement porté sur openprocessing à une date indéfinie. Mais vous pouvez copier l'intégralité du fichier \"sketch.js\" de n'importe quel dossier dans l'éditeur de code d'openprocessing, puis de cliquer sur \"run\".\r\n\r\nIl est aussi possible d'intégrer des librairies javascript externes voici un exemple pour faire cela : https://www.openprocessing.org/sketch/385808\r\n\r\nOpenprocessing est pratique car il permet de se passer de serveur local et permet de créer des portofolio d'applications interactives très facilement.\r\n\r\n![Openprocessing](assets/openprocessing.png)\r\n![Openprocessing](assets/openprocessing-2.png)\r\n\r\n\r\n### editor\r\n\r\nIl existe une application windows, osx ou linux, faisant office d'éditeur et de serveur web. Il est disponnible sur la page de téléchargement de p5js\r\n\r\nhttp://p5js.org/download/\r\n\r\nL'éditeur fait aussi office de serveur, et permet donc de travailler avec des images, vidéos et sons, sans avoir à lancer de serveur local.\r\n\r\n\r\n### developpeur web \r\n\r\nLe plus simple est probablement de [télécharger](http://p5js.org/download/) et d'ajouter la librairie js ou d'utiliser les liens cdn dans votre fichier index.html.\r\n\r\nPour rappel CDN signifie Content Delivery Network et permet de lier son code à des librairies qui sont déjà hébergées en ligne.\r\n\r\nGénéralement un bon éditeur de texte suffit. Parfois il pourra être utile d'utiliser un serveur local pour servir certaines pages demandant accès à des fonctions ou fichiers spécifiques (généralement des pages utilisant des images ou des sons sous formes de fichier doivent être ouvertes avec un serveur local). Il y a des nombreuses possibilités pour cela et beaucoup de documentation en ligne : personnellement j'utilise 'sinatra' un serveur en ruby, simplehttpserver pour python peut-être une alternative, ou d'autres encore via nodejs voire même des logiciels comme mamp.\r\n\r\n\r\n### des librairies\r\n\r\nP5js recense un bon nombre de librairies compatibles et revendiquant le même esprit : http://p5js.org/libraries/\r\nMais il peut aussi être utilisé avec n'impote quelles autres librairies js.\r\n\r\n[^ home](#contenu)<br>\r\n\r\n\r\n\r\n<a name=\"bases\"/>\r\n## Les principes de bases\r\n\r\nUn programme p5js est destiné à être utilisé dans une page web. Généralement en dispose d'un fichier *index.html* qui nous permet de définir notre page web et les fichiers ressources (liens vers les librairies) et d'un fichier *sketch.js* qui va être notre programme écrit en javascript.\r\n\r\n### HTML et JS\r\n\r\nLe fichier *sketch.js* est lié au fichier *index.html* par une déclaration dans ce dernier.\r\n\r\n```HTML\r\n<script language=\"javascript\" type=\"text/javascript\" src=\"sketch.js\"></script>\r\n\r\n```\r\nLorsqu'on ouvre le fichier *index.html* celui-ci executera alors le fichier *sketch.js* dans la page web.\r\n\r\nDans le cas de nos exemples nous trouverons les librairies javascripts dans un dossier **/librairies** dédié : on y trouve *p5.js*, *p5.dom.js*, *p5.sound.js*.\r\n\r\nLe fichier *index.html* ressemblera donc à ceci si on utilise toutes les librairies :\r\n\r\n```HTML\r\n<html>\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <script language=\"javascript\" type=\"text/javascript\" src=\"../libraries/p5.js\"></script>\r\n  <script language=\"javascript\" type=\"text/javascript\" src=\"../libraries/p5.dom.js\"></script>\r\n  <script language=\"javascript\" type=\"text/javascript\" src=\"../libraries/p5.sound.js\"></script>\r\n  <script language=\"javascript\" type=\"text/javascript\" src=\"sketch.js\"></script>\r\n  <style> body {padding: 0; margin: 0;} </style>\r\n</head>\r\n<body>\r\n</body>\r\n</html>\r\n```\r\n\r\n\r\n### p5js\r\n\r\nNotre fichier *sketch.js* est notre code écrit en javascript. Par défaut : il contient deux fonctions nécessaires à l'éxecution des fonctions de l'api p5js (Application Programming Interface)\r\n\r\n```javascript\r\n\r\nfunction setup() {\r\n\r\n}\r\n\r\nfunction draw() {\r\n  \r\n}\r\n\r\n```\r\n\r\nLa fonction **setup()** est executée une fois à chaque chargement de la page, elle est utile pour initialiser des valeurs ou créer des éléments de page web - comme un canvas pour dessiner :\r\n\r\n```javascript\r\nfunction setup() {\r\n    // créer un objet de type HTML5 canvas aux dimension de la fenêtre de notre navigateur\r\n\tcreateCanvas(windowWidth,windowHeight) \r\n}\r\n```\r\n\r\n**windowWidth** et **windowHeight** sont des **variables** disponnible dans processing pour renseigner le programme sur la taille de la fenêtre du navigateur de l'utilisateur.\r\n\r\nUne **variable** est quant à elle un espace mémoire dans le navigateur accessible par notre programme. En javascript nous devrons créer et manipuler des variables régulièrement, mais p5js dispose de certaines variables déjà nommées pour connaitre l'état du navigateur ou la position de la souris ou même encore les touches pressées par l'utilisateur.\r\n\r\nLa fonction **draw()** est elle une boucle infinie : le code entre les deux accolades est éxecuté en boucle par votre navigateur aussi vite que possible. Cela tranche avec le principe évenementiel du javascript, mais ici nous allons faire des applications interactives avec de l'animation.\r\n\r\nVous pourrez trouver la référence du langage p5js ) cette adresse : http://p5js.org/reference/\r\n\r\n\r\n[^ home](#contenu)<br>\r\n\r\n\r\n\r\n<a name=\"dessiner\"/>\r\n## Dessiner avec la souris\r\n\r\nLe premier code sur lequel nous allons travailler est un programme de dessin. Lorsque vous créez un nouveau 'sketch' sur openprocessing vous vous retrouvez avec ce code sous les yeux :\r\n\r\n```javascript\r\n// initialisation du programme\r\nfunction setup() {\r\n  // création d'un canvas à la taille de la fenêtre du navigateur\r\n  createCanvas(windowWidth, windowHeight); \r\n  // création d'un fond gris\r\n  background(100);  \r\n  \r\n} \r\n\r\n// boucle d'execution de notre application\r\nfunction draw() {\r\n  // dessiner un rond à l'endroit de la souris\r\n  ellipse(mouseX, mouseY, 20, 20);\r\n}\r\n```\r\n\r\nChaque execution d'une boucle draw dessine un cercle de 20 pixels au coordonnées de la souris. Il faut noter que le repère de coordonnées dans p5js par défaut place l'origine, c'est à dire le point de coordonées (0,0) en haut à gauche. Les abscisses sont croissantes lorsqu'on se déplace vers la droite et les ordonnées croissantes lorsqu'on se déplace vers le bas.\r\n\r\nVous pouvez expérimenter avec ce programme pour vous en rendre compte : https://www.openprocessing.org/sketch/388459\r\n\r\n**ellipse** est un mot clé permettant de dessiner une ellipse d'une taille précise à une endroit précis en lui passant des **paramètres**, ce sont les valeurs que l'on donne entre parenthèses :\r\n\r\n* les deux premier paramètres sont les coordonnées de l'endroit où dessiner l'ellipse\r\n* les deux suivant sont la largeur et la hauteur de l'ellipse.\r\n\r\n**mouseX** et **mouseY** sont des variables globales définies par processing et donnent la position de la souris au moment du calcul de l'image en les utilisant comme les deux premiers paramètres pour le dessin de notre ellipse on change la position de dessin et on dessine à l'emplacement de la souris.\r\n\r\nLa page de référence concernant l'ellipse nous renseigne sur tout cela : http://p5js.org/reference/#/p5/ellipse\r\n\r\nIl est possible de dessiner bien d'autres formes ou **primitives** en 2d ou en 3d. Il est aussi possible de composer des formes complexes à l'aide de courbes de béziers ou de vertex.\r\n\r\nVoici la page de référence sur les formes : http://p5js.org/reference/#group-Shape\r\n\r\nDans ce programme le fond n'est jamais rafraichit et donc les cercles sont dessinés les uns après les autres sur un fond gris. Si vous rajoutez la commande \r\n\r\n```javascript\r\nbackground(100)\r\n```\r\n\r\nà ce moment là : à chaque image le fond sera remplacé par un fond gris avant dessiner notre ellipse. Le résultat sera alors un rond qui suivra la position de la souris.\r\n\r\n\r\n\r\n[^ home](#contenu)<br>\r\n\r\n\r\n\r\n<a name=\"couleurs\"/>\r\n### Les couleurs et la transparence\r\n \r\nPour coloriser nos dessins il est possible d'utiliser les fonctions **stroke()** ou **noStroke()** et **fill()** ou **noFill()**.\r\n\"stroke\" signifie contour et permet donc de préciser la couleur du trait, et \"fill\" signifie remplissage et permet donc de préciser la couleur de remplissage de la forme. A partir du moment ou sont fonctions sont appelées, elles s'appliquent à tous les dessins qui suivent.\r\n\r\nCe programme vous permettra d'illustrer l'utilisation de ces fonctions : https://www.openprocessing.org/sketch/181425\r\n\r\nLe comportement de ces fonctions est particulièrement modulaire comme le présente la page de doc : http://p5js.org/reference/#/p5/fill\r\n\r\nPour résumer:\r\n\r\n* si vous n'utilisez qu'un paramètre vous êtes en niveau de gris : 0 = noir / 255 = blanc\r\n* si vous utilisez trois paramètres vous êtes en rgb : chaque paramètre étant compris entre 0 et 255 => fill(255,0,0) donnera du rouge\r\n* si vous utilisez quatre paramètres vous ajoutez un cannal alpha pour gérer la transparence : 0 étant transparent et 255 opaque\r\n* vous pouvez aussi utiliser du code hexa-décimal pour rentrer des couleurs\r\n* il est possible de passer du mode rgb au mode hsb grace à la fonction **colorMode()**\r\n\r\nVoici le programme précédent avec de nouvelles couleurs :\r\n\r\n```javascript\r\nfunction setup() {\r\n  createCanvas(windowWidth, windowHeight); \r\n  background(180,100,0);  \r\n  \r\n} \r\n\r\nfunction draw() {\r\n  // cercle à la position de la souris\r\n  fill(255,0,0,50)\r\n  noStroke()\r\n  ellipse(mouseX, mouseY, speed, speed);\r\n }\r\n ```\r\n\r\n\r\n[^ home](#contenu)<br>\r\n\r\n\r\n<a name=\"simuler\"/>\r\n### utilisation de variables :\"Simuler\" un pinceau\r\n\r\nNous allons vouloir maintenant compléxifier notre programme. La première chose que nous allons faire est de rendre le dessin un peu plus sensible. L'idée serait de faire en sorte que lorsque notre geste est rapide les cercles soit gros et qu'ils soient petit quand notre geste est lent (une sorte de pinceau inversé).\r\n\r\nPour cela nous allons essayer de calculer une valeure qui soit proportionelle à la vitesse de déplacement de notre souris. P5js dispose de deux variable dédiées pour connaitre aussi la position de la souris à l'image précédente : elles s'appellent **pmouseX** et **pmouseY**. A partir de la nous pouvons calculer la moyenne du déplacement en abscisses et en ordonnées entre deux images.\r\n\r\nNous allons donc créer une variable javascript que nous allons appeler *speed* pour stocker cette valeur :\r\n\r\n```javascript\r\nvar speed=(abs(pmouseX-mouseX)+abs(pmouseY-mouseY))/2\r\n\r\n```\r\npuis utiliser cette valeur comme paramètre de la taille de nos ellipses :\r\n\r\n```javascript\r\nellipse(mouseX, mouseY, speed, speed)\r\n\r\n```\r\n\r\nNous pouvons aussi calculer une vraie valeur physique en calculant la magnitude du vecteur directeur du mouvement entre deux images ! Il s'agit simplement d'appliquer le théorème de Pythagore :\r\n\r\n```javascript\r\nvar speed=pow(pow(pmouseX-mouseX,2)+pow(pmouseY-mouseY,2),0.5)\r\n```\r\n\r\nNous obtenons alors notre premier exemple disponnible dans le dossier */01_dessiner_01*\r\n\r\n```javascript\r\nfunction setup() {\r\n  createCanvas(windowWidth, windowHeight); \r\n  background(180,100,0);  \r\n  \r\n} \r\n\r\nfunction draw() {\r\n  \r\n  var speed=(abs(pmouseX-mouseX)+abs(pmouseY-mouseY))/2\r\n\r\n  fill(255,0,0,50)\r\n  noStroke()\r\n  ellipse(mouseX, mouseY, speed, speed);\r\n}\r\n```\r\n\r\n![01_dessiner_01](assets/01_dessiner_01.png)\r\nhttps://www.openprocessing.org/sketch/388464\r\n\r\n\r\n[^ home](#contenu)<br>\r\n\r\n\r\n\r\n<a name=\"symetries\"/>\r\n### Réaliser des symétries\r\n\r\nNous allons maitenant réaliser différentes symétries pour compléxifier le rendu de notre programme de dessin. Dans le cadre de notre reprère processing réaliser une symétrie est relativement simple. \r\n\r\nAvec un peu d'astuce on se rend compte qu'une symétrie axiale consiste à faire en sorte que les distance entre deux bords parallèles délimitant un espace de dessin soit la même.\r\n\r\nAinsi : \r\n\r\n```javascript\r\n  ellipse(mouseX, mouseY, speed, speed);\r\n  ellipse(mouseX, windowHeight-mouseY, speed, speed);\r\n```\r\npermet de dessiner une ellipse aux coordonnées de la souris et une par symétrie axiale horizontale au centre de notre canvas.\r\n\r\n\r\n```javascript\r\n  ellipse(mouseX, mouseY, speed, speed);\r\n  ellipse(windowWidth-mouseX, mouseY, speed, speed);\r\n```\r\npermet de dessiner une ellipse aux coordonnées de la souris et une par symétrie axiale verticale au centre de notre canvas.\r\n\r\net finalement : \r\n\r\n```javascript\r\n  ellipse(mouseX, mouseY, speed, speed);\r\n  ellipse(windowWidth-mouseX, windowHeight-mouseY, speed, speed);\r\n```\r\npermet de dessiner une symétrie centrale !\r\n\r\nNotre programme devient donc :\r\n\r\n```javascript\r\nfunction setup() {\r\n  createCanvas(windowWidth, windowHeight); \r\n  background(180,100,0);  \r\n  \r\n} \r\n\r\nfunction draw() {\r\n  \r\n  // magnitude du vecteur directeur de la souris avec pythagore\r\n  //var speed=pow(pow(pmouseX-mouseX,2)+pow(pmouseY-mouseY,2),0.5)/2 \r\n  // ou une expression beaucoup plus simple ... après tout on souhaite juste que la taille des cercles\r\n  // soit  dépendente de la vitesse à laquelle on bouge la souris \r\n  var speed=(abs(pmouseX-mouseX)+abs(pmouseY-mouseY))/2\r\n\r\n    // cercle à la position de la souris\r\n  fill(255,0,0,50)\r\n  noStroke()\r\n  ellipse(mouseX, mouseY, speed, speed);\r\n  \r\n  // symetrie axiale verticale\r\n  fill(255,0,255,50)\r\n  ellipse(mouseX, windowHeight-mouseY, speed, speed);\r\n  \r\n  // symetrie axiale horizontale\r\n  fill(0,0,255,50)\r\n  ellipse(windowWidth-mouseX, mouseY, speed, speed);\r\n  \r\n  // symetrie centrale\r\n  fill(255,255,0,50)\r\n  ellipse(windowWidth-mouseX, windowHeight-mouseY, speed, speed);\r\n}\r\n\r\n```\r\n\r\n![01_dessiner_02](assets/01_dessiner_02.png)\r\nhttps://www.openprocessing.org/sketch/388181\r\n\r\nPour vous exercer vous pouvez essayer de dessiner des lignes (fonction **line()**)provenant du centre de la fenêtre à la souris, ainsi qu'à ses quatres positions symétriques. Vous pouvez aussi faire varier la taille des traits grace à la fonction **strokeWeight()**. Ce qui vous donnera un résultat similaire à celui-ci\r\n\r\n![01_dessiner_03](assets/01_dessiner_03.png)\r\n(https://www.openprocessing.org/sketch/388511)\r\n\r\n\r\n[^ home](#contenu)<br>\r\n\r\n\r\n\r\n<a name=\"fonctions\"/>\r\n### Fonctions\r\n\r\nEn javascript, il est assez facile de définir de nouvelles fonctions : il suffit de créer une variable un peu particulière, une variable qui est en réalité un bout de code js. Par exemple pour créer une fonction permettant de dessiner un carré il suffit d'écrire ceci à la racine de notre fichier sketch.js (c'est à dire en dehors de la fonction draw ou de la fonction setup)\r\n\r\n```javascript\r\nvar draw_square = function(x,y,size){ // on crée la fonction et on définit les paramètres nécessaires\r\n\trect(x,y,size,size) // code nécessaire au dessin d'un carré en fonction des paramètres\r\n}\r\n```\r\n\r\nPour utiliser cette fonction, il nous suffit alors cette fois dans le **draw()** de l'appeler avec les paramètres adéquats.\r\n```javascript\r\ndraw_square(25,25,50) // dessiner un carré au coordonnées (25,25) dont le côté fait 50 pixels.\r\n```\r\n\r\n[^ home](#contenu)<br>\r\n\r\n\r\n<a name=\"transformations\"/>\r\n### Transformation de l'espace : effet spirographe\r\n\r\nPour l'instant nous avons vu que le repère dans lequel on exprimait les coordonnées dans était fixe. Mais il est possible de le déplacer et de le faire tourner. Cela peu notament être utile pour faire tourner un carré autour de son centre.\r\n\r\nPour cela il faut utiliser les fonctions **translate()** et **rotate()**\r\n\r\nCet exemple interactif vous permettra probablement de mieux comprendre l'utilisation conjointe des deux fonctions. Il est aussi important de savoir qu'il existe deux fonctions **push()** et **pop()** qui fonctionnent de manière conjointe : **push()** permet de créer un nouveau repère pour le transformer et **pop()** permet de restaurer le repère original de processing. Si jamais vous utilisez push() vous devez utiliser pop() sous réserve d'avoir des erreurs à l'exécution.\r\n\r\nNous allons pouvoir maintenant faire tourner un rectangle autour de son centre en modifiant la fonction que nous avions précédement écrite :\r\n\r\n```javascript\r\nvar draw_rect = function(x,y,size,rot){\r\n  push()\r\n  rectMode(CENTER) // utiliser le centre du carré comme ancre de dessin\r\n  translate(x,y) // déplacer le repère\r\n  rotate(rot) // le faire tourner sur lui même en fonction d'une valeur d'angle\r\n  rect(0,0,size  ,size)\r\n  pop()\r\n }\r\n``` \r\n\r\n**push()** et **pop()** peuvent aussi être imbriqués les uns dans les autres.\r\n\r\n```javascript\r\nvar draw_rect = function(x,y,size,rot){\r\n  // nouveau repère r1\r\n  push() \r\n  rectMode(CENTER)\r\n  translate(x,y)\r\n  rotate(rot)\r\n  rect(0,0,size  ,size)\r\n\r\n  // nouveau repère r2 qui bénificie encore des transformation de r1\r\n  push() \r\n  translate(-50,-50) // notre rectangle va tourner autour du centre de r1 à une distance calculable par pythagore : d = pow(50*50+50*50,0.5)\r\n  rotate(PI/2)\r\n  rect(0,0,size  ,size)\r\n  pop() // on supprime les transformation de r2\r\n\r\n  // et on crée un nouveau repère r3 qui est donc dans l'état de r1\r\n  push() \r\n  translate(100,100) // notre rectangle va tourner autour du centre de r1 à une distance calculable par pythagore : d = pow(100*100+100*100,0.5)\r\n  rotate(rot*3) // et il va tourner sur lui même\r\n  rect(0,0,size  ,size)\r\n  pop() // on supprime les transformation de r3\r\n\r\n  pop() //on supprime les transformation de r1\r\n\r\n  // nous sommes de nouveau dans le repère d'origine\r\n}\r\n\r\n```\r\n\r\nLe programme suivant garde se principe, ajoute un niveau de rotation et  ne dessine plus de rectangles mais uniquement des lignes représentant les repères tournants les uns autour des autres :\r\n\r\n```javascript\r\nvar draw_lines = function(x,y,size,rot){\r\n\r\n    strokeWeight(0.15)\r\n  // nouveau repère r1\r\n  push() \r\n  rectMode(CENTER)\r\n  translate(x,y)\r\n  rotate(rot*0.15)\r\n  stroke(75)\r\n  // dessiner une croix\r\n  line(0,size,0,-size)\r\n  line(-size,0,size,0)\r\n\r\n  // nouveau repère r2 qui bénificie encore des transformation de r1\r\n  push() \r\n  rotate(rot)\r\n  translate(-size,-size) // notre croix va tourner autour du centre de r1 à une distance calculable par pythagore : d = pow(50*50+50*50,0.5)\r\n  rotate(PI/2)\r\n  stroke(50)\r\n  line(0,size,0,-size)\r\n  line(-size,0,size,0)\r\n  pop() // on supprime les transformation de r2\r\n\r\n  // et on crée un nouveau repère r3 qui est donc dans l'état de r1\r\n  push() \r\n  stroke(0)\r\n  rotate(rot)\r\n  translate(size*3,size*3) // notre croix va tourner autour du centre de r1 à une distance calculable par pythagore : d = pow(100*100+100*100,0.5)\r\n  rotate(rot*7  ) // et il va tourner sur lui même\r\n   // dessiner le repère\r\n  line(0,size,0,-size)\r\n  line(-size,0,size,0)\r\n\r\n  push() // on pousse un nouveau repère r4 qui bénéficie des transformation conjointe de r1 et r3\r\n  translate(size*2,size*2) // notre croix va tourner autour du centre de r3 à une distance calculable par pythagore : d = pow(35*35+35*35,0.5)\r\n  rotate(rot*2 ) // et il va tourner sur lui même\r\n   // dessiner le repère\r\n  line(0,size,0,-size)\r\n  line(-size,0,size,0)\r\n  pop() // on supprime les transformation de r4\r\n\r\n  pop() // on supprime les transformation de r3\r\n\r\n  pop() //on supprime les transformation de r1\r\n\r\n  // nous sommes de nouveau dans le repère d'origine\r\n}\r\n\r\n\r\nfunction setup() {\r\n  createCanvas(windowWidth, windowHeight)\r\n  background(255)\r\n  \r\n} \r\n\r\nfunction draw() {\r\n\r\n\r\n  var size = (abs(pmouseX-mouseX) + abs(pmouseY - mouseY)) + 25\r\n  stroke(0)\r\n  fill(0,180)\r\n  draw_lines(mouseX, mouseY, size , frameCount/50)\r\n\r\n}\r\n\r\n\r\n\r\n```\r\n\r\n![01_dessiner_04](assets/01_dessiner_04.png)\r\n\r\nhttps://www.openprocessing.org/sketch/388514\r\n\r\n\r\n[^ home](#contenu)<br>\r\n\r\n\r\n<a name=\"spray\"/>\r\n### Effet \"Spray-can\"\r\n\r\n\r\n[^ home](#contenu)<br>\r\n\r\n\r\n\r\n\r\n<a name=\"animation\"/>\r\n## Animer un déplacement\r\n\r\n\r\n\r\n\r\n[^ home](#contenu)<br>\r\n\r\n\r\n\r\n<a name=\"grilles\"/>\r\n## Grilles et patterns\r\n\r\n- transformation de l'espace\r\n- images, filtres et blends\r\n\r\n\r\n\r\n\r\n[^ home](#contenu)<br>\r\n\r\n\r\n\r\n<a name=\"dom\"/>\r\n## DOM\r\ngui elements\r\nvideo + dom\r\nmode instance de p5js\r\n\r\n\r\n[^ home](#contenu)<br>\r\n\r\n\r\n\r\n<a name=\"socket\"/>\r\n## websocket et SocketIO\r\n\r\n\r\n[^ home](#contenu)<br>\r\n\r\n\r\n<a name=\"ressources\"/>\r\n## Ressources\r\n\r\n* Référence du langage : http://p5js.org/reference/\r\n\r\n* Exemples interactifs de p5js.org : http://p5js.org/examples/\r\n\r\n* Tutorials sur p5js.org : http://p5js.org/tutorials/\r\n\r\n* Vidéos de Daniel Shiffman : https://www.youtube.com/user/shiffman/playlists?shelf_id=14&view=50&sort=dd\r\n\r\n* Nature of Code de Daniel Shiffman : http://natureofcode.com/book/\r\n\r\n* Travailler avec p5.sound : https://github.com/b2renger/p5js_sound_examples\r\n\r\n* Expérimentations typographiques : https://b2renger.github.io/p5js_typo/\r\n\r\n* Exemples Computer Vision : https://kylemcdonald.github.io/cv-examples/\r\n\t\r\n* Introduction web sockets et nodejs : link tuto  https://github.com/processing/p5.js/wiki/p5.js\r\n\r\n[^ home](#contenu)<br>\r\n\r\n\r\n\r\n\r\n<a name=\"references\"/>\r\n## Ressources\r\n\r\nQuelques projets liant le web à des espaces physiques :\r\n\r\n* Liil : installation de projection mapping et visualisation de compte twitter : https://www.youtube.com/watch?v=0YLhYUfJCBA\r\n\r\n* Fields : utilisation des smartphones de l'audience comme procédé de diffusion via la web audio api : http://funktion.fm/#/projects/fields-infos\r\n\r\n* Google : contrôle d'installation robotiques à distance via des pages web : https://www.youtube.com/watch?v=RrgjufJhmwk\r\n\r\n* Sidlee : déploiement d'un parce de capteur et dashboard de visualisation (les capteurs sont aujourd'hui déconnectés) : http://dashboard.sidlee.com/\r\n\r\n\r\nDes projets exclusivement web :\r\n\r\n* Aaron Koblin : \r\n\r\n\t* Bicycle built for 2000 : http://www.bicyclebuiltfortwothousand.com/ \r\n\r\n\t* original daisy bell : https://www.youtube.com/watch?v=41U78QP8nBk\r\n\r\n* Chris Milk & Aaron Koblin :\r\n\r\n\t* http://www.thewildernessdowntown.com/\r\n\r\n\t* http://www.thejohnnycashproject.com/\r\n\r\n\t* http://www.exquisiteforest.com/\r\n\r\n* Vincent Morisset & arcade fire : http://www.sprawl2.com/\r\n\r\n* Carp and seagull : http://thecarpandtheseagull.thecreatorsproject.com/#\r\n\r\n* Plink : musique collaborative : http://dinahmoelabs.com/#plink\r\n\r\n\r\n[^ home](#contenu)<br>\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}